var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"APIs","title":"API","text":"","category":"section"},{"location":"api/#IntervalSets.AbstractInterval","page":"APIs","title":"IntervalSets.AbstractInterval","text":"A subtype of AbstractInterval{T} represents an interval subset of type T, that provides endpoints, closedendpoints.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalSets.ClosedInterval","page":"APIs","title":"IntervalSets.ClosedInterval","text":"A ClosedInterval(left, right) is an interval set that includes both its upper and lower bounds. In mathematical notation, the constructed range is [left, right].\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalSets.Domain","page":"APIs","title":"IntervalSets.Domain","text":"A subtype of Domain{T} represents a subset of type T, that provides in.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalSets.Interval","page":"APIs","title":"IntervalSets.Interval","text":"An Interval{L,R}(left, right) where L,R are :open or :closed is an interval set containg x such that\n\nleft ≤ x ≤ right if L == R == :closed\nleft < x ≤ right if L == :open and R == :closed\nleft ≤ x < right if L == :closed and R == :open, or\nleft < x < right if L == R == :open\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalSets.OpenInterval","page":"APIs","title":"IntervalSets.OpenInterval","text":"An TypedEndpointsInterval{:open,:open}(left, right) is an interval set that includes both its upper and lower bounds. In mathematical notation, the constructed range is (left, right).\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalSets.TypedEndpointsInterval","page":"APIs","title":"IntervalSets.TypedEndpointsInterval","text":"A subtype of TypedEndpointsInterval{L,R,T} where L and R are :open or :closed, that represents an interval subset of type T, and provides endpoints.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.clamp-Tuple{Any, IntervalSets.TypedEndpointsInterval{:closed, :closed}}","page":"APIs","title":"Base.clamp","text":"clamp(t, i::ClosedInterval)\n\nClamp the scalar t such that the result is in the interval i.\n\nExamples\n\njulia> clamp(1.2, 1..2)\n1.2\n\njulia> clamp(2.2, 1..2)\n2.0\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.findall-Tuple{Base.Fix2{typeof(in), <:Interval}, AbstractRange}","page":"APIs","title":"Base.findall","text":"findall(in(interval), x::AbstractRange)\n\nReturn all indices i for which x[i] ∈ interval, specialized for the case where x is a range, which enables constant-time complexity.\n\nExamples\n\njulia> x = range(0,stop=3,length=10)\n0.0:0.3333333333333333:3.0\n\njulia> collect(x)'\n1×10 adjoint(::Vector{Float64}) with eltype Float64:\n 0.0  0.333333  0.666667  1.0  1.33333  1.66667  2.0  2.33333  2.66667  3.0\n\njulia> findall(in(1..6), x)\n4:10\n\nIt also works for decreasing ranges:\n\njulia> y = 8:-0.5:0\n8.0:-0.5:0.0\n\njulia> collect(y)'\n1×17 adjoint(::Vector{Float64}) with eltype Float64:\n 8.0  7.5  7.0  6.5  6.0  5.5  5.0  4.5  …  3.0  2.5  2.0  1.5  1.0  0.5  0.0\n\njulia> findall(in(1..6), y)\n5:15\n\njulia> findall(in(Interval{:open,:closed}(1,6)), y) # (1,6], does not include 1\n5:14\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.mod-Tuple{Any, IntervalSets.TypedEndpointsInterval{:closed, :closed}}","page":"APIs","title":"Base.mod","text":"mod(x, i::AbstractInterval)\n\nFind y in the i interval such that x  y pmod w, where w = width(i).\n\nExamples\n\njulia> I = 2.5..4.5;\n\njulia> mod(3.0, I)\n3.0\n\njulia> mod(5.0, I)\n3.0\n\njulia> mod(2.5, I)\n2.5\n\njulia> mod(4.5, I)  # (a in I) does not imply (a == mod(a, I)) for closed intervals\n2.5\n\njulia> mod(4.5, Interval{:open, :closed}(2.5, 4.5))\n4.5\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.range-Tuple{IntervalSets.TypedEndpointsInterval{:closed, :closed}}","page":"APIs","title":"Base.range","text":"range(i::ClosedInterval; step, length)\nrange(i::ClosedInterval, length::Integer)\n\nConstructs a range of a specified step or length.\n\nExamples\n\njulia> range(1..2, 8)\n1.0:0.14285714285714285:2.0\n\njulia> range(1, 2, 8)\n1.0:0.14285714285714285:2.0\n\njulia> range(1..2, step=0.2)\n1.0:0.2:2.0\n\njulia> range(1, 2, step=0.2)\n1.0:0.2:2.0\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.range-Tuple{IntervalSets.TypedEndpointsInterval{:closed, :open}}","page":"APIs","title":"Base.range","text":"range(i::Interval{:closed,:open}; length)\nrange(i::Interval{:closed,:open}, length::Integer)\nrange(i::Interval{:open,:closed}; length)\nrange(i::Interval{:open,:closed}, length::Integer)\n\nConstructs a range of a specified length with step=width(i)/length.\n\nExamples\n\njulia> range(iv\"[1, 2)\", 7)  # Does not contain right endpoint\n1.0:0.14285714285714285:1.8571428571428572\n\njulia> range(iv\"(1, 2]\", 7)  # Does not contain left endpoint\n1.1428571428571428:0.14285714285714285:2.0\n\njulia> range(1, 2, 8)\n1.0:0.14285714285714285:2.0\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.range-Tuple{IntervalSets.TypedEndpointsInterval{:open, :open}}","page":"APIs","title":"Base.range","text":"range(i::OpenInterval; length)\nrange(i::OpenInterval, length::Integer)\n\nConstructs a range of a specified length with step = width(i) / (length + 1).\n\nExamples\n\njulia> range(iv\"(1, 4)\", 5)  # Does not contain the endpoints\n1.5:0.5:3.5\n\njulia> range(1, 4, 7)\n1.0:0.5:4.0\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalSets.:..-Tuple{Any, Any}","page":"APIs","title":"IntervalSets.:..","text":"iv = l..r\n\nConstruct a ClosedInterval iv spanning the region from l to r.\n\nExamples\n\njulia> 1..2\n1 .. 2\n\njulia> 3..1  # Empty interval set can be defined\n3 .. 1\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalSets.:±-Tuple{Any, Any}","page":"APIs","title":"IntervalSets.:±","text":"iv = center ± halfwidth\n\nConstruct a ClosedInterval iv spanning the region from center - halfwidth to center + halfwidth.\n\nExamples\n\njulia> 3 ± 2\n1 .. 5\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalSets.closedendpoints-Tuple{AI} where AI<:AbstractInterval","page":"APIs","title":"IntervalSets.closedendpoints","text":"closedendpoints(d::AI) where AI<:AbstractInterval\n\nA tuple of Bool's encoding whether the left/right endpoints are closed.\n\nExamples\n\njulia> closedendpoints(iv\"[1,2]\")\n(true, true)\n\njulia> closedendpoints(iv\"(1,2]\")\n(false, true)\n\njulia> closedendpoints(iv\"[2,1)\")\n(true, false)\n\njulia> closedendpoints(iv\"(2,1)\")\n(false, false)\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalSets.endpoints-Tuple{AI} where AI<:AbstractInterval","page":"APIs","title":"IntervalSets.endpoints","text":"endpoints(d::AI) where AI<:AbstractInterval\n\nA tuple containing the left and right endpoints of the interval.\n\nExamples\n\njulia> endpoints(iv\"[1,2]\")\n(1, 2)\n\njulia> endpoints(iv\"(2,1)\")\n(2, 1)\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalSets.isclosedset-Tuple{AbstractInterval}","page":"APIs","title":"IntervalSets.isclosedset","text":"isclosedset(d::AbstractInterval)\n\nIs the interval closed set?\n\nExamples\n\njulia> isclosedset(iv\"[1,2]\")\ntrue\n\njulia> isclosedset(iv\"(1,2]\")\nfalse\n\njulia> isclosedset(iv\"[1,2)\")\nfalse\n\njulia> isclosedset(iv\"(1,2)\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalSets.isleftclosed-Tuple{AbstractInterval}","page":"APIs","title":"IntervalSets.isleftclosed","text":"isleftclosed(d::AbstractInterval)\n\nIs the interval closed at the left endpoint?\n\nExamples\n\njulia> isleftclosed(iv\"[1,2]\")\ntrue\n\njulia> isleftclosed(iv\"(2,1)\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalSets.isleftopen-Tuple{AbstractInterval}","page":"APIs","title":"IntervalSets.isleftopen","text":"isleftopen(d::AbstractInterval)\n\nIs the interval open at the left endpoint?\n\nExamples\n\njulia> isleftopen(iv\"[1,2]\")\nfalse\n\njulia> isleftopen(iv\"(2,1)\")\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalSets.isopenset-Tuple{AbstractInterval}","page":"APIs","title":"IntervalSets.isopenset","text":"isopenset(d::AbstractInterval)\n\nIs the interval open set?\n\nExamples\n\njulia> isopenset(iv\"[1,2]\")\nfalse\n\njulia> isopenset(iv\"(1,2]\")\nfalse\n\njulia> isopenset(iv\"[1,2)\")\nfalse\n\njulia> isopenset(iv\"(1,2)\")\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalSets.isrightclosed-Tuple{AbstractInterval}","page":"APIs","title":"IntervalSets.isrightclosed","text":"isrightclosed(d::AbstractInterval)\n\nIs the interval closed at the right endpoint?\n\nExamples\n\njulia> isrightclosed(iv\"[1,2]\")\ntrue\n\njulia> isrightclosed(iv\"(2,1)\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalSets.isrightopen-Tuple{AbstractInterval}","page":"APIs","title":"IntervalSets.isrightopen","text":"isrightopen(d::AbstractInterval)\n\nIs the interval open at the right endpoint?\n\nExamples\n\njulia> isrightopen(iv\"[1,2]\")\nfalse\n\njulia> isrightopen(iv\"(2,1)\")\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalSets.leftendpoint-Tuple{AbstractInterval}","page":"APIs","title":"IntervalSets.leftendpoint","text":"leftendpoint(d::AbstractInterval)\n\nThe left endpoint of the interval.\n\nExamples\n\njulia> leftendpoint(iv\"[1,2]\")\n1\n\njulia> leftendpoint(iv\"(2,1)\")\n2\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalSets.rightendpoint-Tuple{AbstractInterval}","page":"APIs","title":"IntervalSets.rightendpoint","text":"rightendpoint(d::AbstractInterval)\n\nThe right endpoint of the interval.\n\nExamples\n\njulia> rightendpoint(iv\"[1,2]\")\n2\n\njulia> rightendpoint(iv\"(2,1)\")\n1\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalSets.searchsorted_interval-Union{Tuple{R}, Tuple{L}, Tuple{Any, Interval{L, R}}} where {L, R}","page":"APIs","title":"IntervalSets.searchsorted_interval","text":"searchsorted_interval(a, i::Interval; [rev=false])\n\nReturn the range of indices of a which is inside of the interval i (using binary search), assuming that a is already sorted. Return an empty range located at the insertion point if a does not contain values in i.\n\nExamples\n\njulia> searchsorted_interval([1,2,3,5], 2..4)\n2:3\n\njulia> searchsorted_interval([1,2,3,5], 4..1)\n4:3\n\njulia> searchsorted_interval(Float64[], 1..3)\n1:0\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalSets.width-Tuple{AbstractInterval}","page":"APIs","title":"IntervalSets.width","text":"w = width(iv)\n\nCalculate the width (max-min) of interval iv. Note that for integers l and r, width(l..r) = length(l:r) - 1.\n\nExamples\n\njulia> width(2..7)\n5\n\njulia> length(2:7)\n6\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalSets.@iv_str-Tuple{Any}","page":"APIs","title":"IntervalSets.@iv_str","text":"@iv_str -> Interval\n\nConstruct an interval with mathematical notation such as iv\"(1,2]\".\n\nExamples\n\njulia> iv\"[1,2]\"\n1 .. 2\n\njulia> iv\"[1,2)\"\n1 .. 2 (closed-open)\n\njulia> iv\"(1,2]\"\n1 .. 2 (open-closed)\n\njulia> iv\"(1,2)\"\n1 .. 2 (open)\n\n\n\n\n\n","category":"macro"},{"location":"#IntervalSets.jl","page":"Home","title":"IntervalSets.jl","text":"A Julia package implementing interval sets.\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Aqua QA)\n\nnote: Documentation\nThe documentation is still work in progress. For more information, see alsoREADME in the repository\nTests in the repositoryFeel free to open pull requests and improve this document!","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"pkg> add IntervalSets","category":"section"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"using IntervalSets\ni1 = 1.0 .. 3.0\ni2 = OpenInterval(0..4)\ni1 ⊆ i2\ni2 ⊆ i1\n\nCurrently this package defines one concrete type, Interval. These define the set spanning from a to b, meaning the interval is defined as the set x    a  x  b. This is sometimes written ab (mathematics syntax, not Julia syntax) or ab.\n\nOptionally, Interval{L,R} can represent open and half-open intervals. The type parameters L and R correspond to the left and right endpoint respectively. The notation ClosedInterval is short for Interval{:closed,:closed}, while OpenInterval is short for Interval{:open,:open}. For example, the interval Interval{:open,:closed} corresponds to the set (ab = x    a  x  b.","category":"section"},{"location":"#More-examples","page":"Home","title":"More examples","text":"","category":"section"},{"location":"#Constructors","page":"Home","title":"Constructors","text":"ClosedInterval{Float64}(1,3)\nOpenInterval{Float64}(1,3)\nInterval{:open, :closed}(1,3)\nOpenInterval(0.5..2.5)  # construct `OpenInterval` from `ClosedInterval`\n\nThe ± operator and .. creates ClosedInterval instance.\n\n0.5..2.5\n1.5 ± 1  # \\pm<TAB>\n\nThere is also a useful string macro @iv_str to define an interval with mathematical notations such as (ab.\n\niv\"[1,2]\"\niv\"[1,2)\"\niv\"(1,2]\"\niv\"(1,2)\"","category":"section"},{"location":"#Set-operations","page":"Home","title":"Set operations","text":"1.75 ∈ 1.5±1  # \\in<TAB>; can also use `in`\n0 ∈ 1.5±1\n1 ∈ OpenInterval(0..1)\nintersect(1..5, 3..7)   # can also use `a ∩ b`, where the symbol is \\cap<TAB>\nisempty(intersect(1..5, 10..11))\n(0.25..5) ∪ (3..7.4)  # \\cup<TAB>; can also use `union()`\nisclosedset(0.5..2.0)\nisopenset(OpenInterval(0.5..2.5))\nisleftopen(2..3)\n(0.25..5) ∪ (6..7.4)  # union of interval must be an interval","category":"section"},{"location":"#Visualization","page":"Home","title":"Visualization","text":"Intervals can be visulalized with Plots.plot function.\n\nusing IntervalSets, Plots\nplot(iv\"(1,2)\")\nplot!(iv\"[3,6)\")\nplot!(iv\"[5,7)\")\nsavefig(\"plot-intervals.png\") # hide\nnothing # hide\n\n(Image: )\n\nThe offset keyword argument is useful for avoid duplication.\n\nplot(iv\"[1,3]\")\nplot!(iv\"(2,4)\"; offset=-0.1, ylims=(-1,1))\nsavefig(\"plot-intervals-offset.png\") # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"#Importing-the-..-operator","page":"Home","title":"Importing the .. operator","text":"To import the .. operator, use import IntervalSets: (..). The parantheses are necessary to avoid parsing issues.\n\nimport IntervalSets: (..)\nimport IntervalSets.(..)  # This is also okay","category":"section"}]
}
